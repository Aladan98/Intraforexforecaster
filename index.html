<!DOCTYPE html>
<html>
<head>
    <title>Forex Cluster Analysis - Pure Price Action</title>
    <meta name="description" content="Advanced Forex cluster analysis with dynamic clustering, exponential weighting, and candlestick pattern recognition">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); 
            color: #e2e8f0; 
            padding: 10px;
            font-size: 13px;
            min-height: 100vh;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        .header {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 1px solid #475569;
            padding: 25px;
            margin-bottom: 25px;
            text-align: center;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .header p {
            color: #94a3b8;
            font-size: 1.1rem;
        }
        .controls {
            background: #1e293b;
            border: 1px solid #334155;
            padding: 25px;
            margin-bottom: 25px;
            border-radius: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .settings-group {
            display: grid;
            gap: 18px;
        }
        .settings-group h3 {
            color: #22c55e;
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 2px solid #22c55e;
            padding-bottom: 8px;
        }
        input, button, select { 
            margin: 5px 0; 
            padding: 12px 16px;
            background: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            font-family: inherit;
            font-size: 13px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #22c55e;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #f1f5f9;
        }
        button {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            cursor: pointer;
            font-weight: 600;
            border: none;
            transition: all 0.3s ease;
        }
        button:hover { 
            background: linear-gradient(135deg, #16a34a, #15803d);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }
        button:disabled { 
            background: #374151; 
            color: #6b7280; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }
        .upload-area {
            background: #0f172a;
            border: 2px dashed #475569;
            padding: 40px;
            text-align: center;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-area:hover { 
            border-color: #22c55e; 
            background: rgba(34, 197, 94, 0.05);
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            background: #1e293b;
            margin-bottom: 25px;
            font-size: 12px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        th, td { 
            border: 1px solid #334155; 
            padding: 12px 16px; 
            text-align: left;
        }
        th { 
            background: linear-gradient(135deg, #334155, #475569); 
            font-weight: 600;
            color: #f1f5f9;
            position: sticky;
            top: 0;
        }
        tbody tr:hover { background: rgba(34, 197, 94, 0.1); }
        .top-cluster { 
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1)); 
            font-weight: 600; 
            border-left: 4px solid #22c55e;
        }
        .bullish { color: #22c55e; font-weight: 600; }
        .bearish { color: #ef4444; font-weight: 600; }
        .neutral { color: #eab308; font-weight: 600; }
        .section {
            background: #1e293b;
            border: 1px solid #334155;
            padding: 25px;
            margin-bottom: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .forecast-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        .forecast-card {
            background: linear-gradient(135deg, #1e293b, #334155);
            border: 1px solid #475569;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .forecast-card h3 {
            color: #22c55e;
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            border-bottom: 2px solid #22c55e;
            padding-bottom: 10px;
        }
        .big-number {
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            margin: 20px 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            padding: 8px 0;
            border-bottom: 1px solid #334155;
        }
        .data-row:last-child { border-bottom: none; }
        .trade-suggestion {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05));
            border: 1px solid #22c55e;
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            border-left: 4px solid #22c55e;
        }
        .no-trade {
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.1), rgba(234, 179, 8, 0.05));
            border: 1px solid #eab308;
            border-left: 4px solid #eab308;
        }
        .status { 
            margin-top: 20px; 
            padding: 16px;
            background: #0f172a;
            border-radius: 8px;
            border-left: 4px solid #22c55e;
        }
        .success { color: #22c55e; }
        .error { color: #ef4444; }
        .loading { color: #eab308; }
        .position-card {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 2px solid #22c55e;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
        }
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .badge-success { background: #22c55e; color: #000; }
        .badge-warning { background: #eab308; color: #000; }
        .badge-danger { background: #ef4444; color: #fff; }
        .enhanced-features {
            background: linear-gradient(135deg, #0f172a, #1e293b);
            border: 1px solid #334155;
            padding: 30px;
            border-radius: 12px;
            margin-top: 30px;
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .feature-item {
            background: rgba(34, 197, 94, 0.05);
            padding: 20px;
            border-radius: 8px;
            border-left: 3px solid #22c55e;
        }
        .feature-item h4 {
            color: #22c55e;
            font-weight: 600;
            margin-bottom: 10px;
        }
        @media (max-width: 768px) {
            .controls { grid-template-columns: 1fr; }
            .forecast-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>FOREX CLUSTER ANALYSIS</h1>
        <p>Advanced Pure Price Action • Dynamic Clustering • Pattern Recognition</p>
    </div>

    <div class="controls">
        <div>
            <h3>Market Settings</h3>
            <div class="settings-group">
                <div>
                    <label for="forexPair">Forex Pair:</label>
                    <input type="text" id="forexPair" placeholder="EURUSD" value="EURUSD"/>
                </div>
                <div>
                    <label for="candleSize">Timeframe:</label>
                    <select id="candleSize">
                        <option value="5m">5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="30m" selected>30 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                    </select>
                </div>
                <div>
                    <label for="basePips">Base Cluster Size (Pips):</label>
                    <input type="number" id="basePips" value="5" min="1"/>
                </div>
                <div>
                    <label for="accountBalance">Account Balance ($):</label>
                    <input type="number" id="accountBalance" value="10000" min="1000"/>
                </div>
            </div>
        </div>
        
        <div>
            <h3>Risk & Analysis Settings</h3>
            <div class="settings-group">
                <div>
                    <label for="riskPercentage">Risk per Trade (%):</label>
                    <input type="number" id="riskPercentage" value="2" min="0.5" max="10" step="0.5"/>
                </div>
                <div>
                    <label for="minRiskReward">Min Risk:Reward:</label>
                    <input type="number" id="minRiskReward" value="2.0" min="1" max="5" step="0.1"/>
                </div>
                <div>
                    <label for="minConfidence">Min Confidence (%):</label>
                    <input type="number" id="minConfidence" value="60" min="30" max="90"/>
                </div>
                <div>
                    <label for="volatilityLookback">Volatility Lookback:</label>
                    <input type="number" id="volatilityLookback" value="20" min="5" max="100"/>
                </div>
            </div>
        </div>
        
        <div>
            <h3>Data Upload & Analysis</h3>
            <div class="upload-area" onclick="document.getElementById('csvFile').click()">
                <p><strong>📊 Click to Upload CSV File</strong></p>
                <p style="color: #94a3b8; font-size: 12px; margin-top: 12px;">
                    Required: Date, Open, High, Low, Close<br>
                    Optional: Volume<br>
                    <strong>Analysis starts automatically!</strong>
                </p>
            </div>
            <input type="file" id="csvFile" accept=".csv" style="display: none;"/>
            
            <div style="margin-top: 20px;">
                <button onclick="analyzeData()" id="analyzeBtn" disabled>🚀 ANALYZE CLUSTERS</button>
                <button onclick="downloadCSV()" id="exportBtn" disabled>📥 EXPORT DATA</button>
            </div>
            <div>
                <label for="exponentialDecay">Exponential Decay:</label>
                <input type="number" id="exponentialDecay" value="0.1" min="0.01" max="1" step="0.01"/>
            </div>
        </div>
    </div>

    <div id="status" class="status">Upload CSV data to begin enhanced analysis...</div>

    <div class="forecast-grid" id="forecastSection" style="display: none;">
        <div class="forecast-card">
            <h3>🎯 TRADING SIGNAL</h3>
            <div id="tradingForecast">No analysis yet...</div>
        </div>
        <div class="forecast-card">
            <h3>📈 CLUSTER SUMMARY</h3>
            <div id="clusterSummary">No analysis yet...</div>
        </div>
        <div class="position-card">
            <h3>💰 POSITION SIZING</h3>
            <div id="positionSizing">No analysis yet...</div>
        </div>
    </div>

    <div class="section" id="clustersSection" style="display: none;">
        <h3>📊 ENHANCED CLUSTER ANALYSIS</h3>
        <div id="clustersTable">No data analyzed yet...</div>
    </div>

    <div class="enhanced-features">
        <h3 style="color: #22c55e; font-size: 1.5rem; margin-bottom: 20px;">🚀 Enhanced Features</h3>
        <div class="features-grid">
            <div class="feature-item">
                <h4>Dynamic Clustering</h4>
                <p>Cluster size automatically adjusts based on recent market volatility using ATR-like calculations for optimal precision.</p>
            </div>
            <div class="feature-item">
                <h4>Exponential Weighting</h4>
                <p>Recent candles weighted more heavily in confidence scoring with configurable decay factor for recency bias.</p>
            </div>
            <div class="feature-item">
                <h4>Full Dataset Analysis</h4>
                <p>Analyzes complete CSV data automatically without time restrictions for comprehensive market insights.</p>
            </div>
            <div class="feature-item">
                <h4>Pattern Recognition</h4>
                <p>Candlestick microstructure analysis including pin bars, engulfing patterns, inside bars, and doji detection.</p>
            </div>
            <div class="feature-item">
                <h4>Smart Risk Management</h4>
                <p>Volatility-adjusted stop losses with minimum risk:reward ratios and intelligent position sizing calculations.</p>
            </div>
            <div class="feature-item">
                <h4>Trend Bias Integration</h4>
                <p>Short-term trend alignment using median price calculations without traditional indicators.</p>
            </div>
        </div>
    </div>
</div>

<script>
let csvData = [];
let analysis = [];
let settings = {
    forexPair: 'EURUSD',
    candleSize: '30m',
    basePips: 5,
    accountBalance: 10000,
    riskPercentage: 2,
    pipValue: 0.0001,
    minRiskReward: 2.0,
    volatilityLookback: 20,
    exponentialDecay: 0.1,
    minConfidence: 60
};

document.getElementById('csvFile').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
        parseCSV(evt.target.result);
    };
    reader.readAsText(file);
});

// Update settings when form changes
['forexPair', 'candleSize', 'basePips', 'accountBalance', 'riskPercentage', 'minRiskReward', 'volatilityLookback', 'exponentialDecay', 'minConfidence'].forEach(id => {
    document.getElementById(id).addEventListener('change', e => {
        let value = e.target.value;
        if (['basePips', 'accountBalance', 'volatilityLookback', 'minConfidence'].includes(id)) {
            value = parseInt(value) || settings[id];
        } else if (['riskPercentage', 'minRiskReward', 'exponentialDecay'].includes(id)) {
            value = parseFloat(value) || settings[id];
        }
        settings[id] = value;
        
        if (id === 'forexPair') {
            settings.pipValue = detectPipValue(value);
        }
        
        // Auto-reanalyze if data exists and settings change
        if (csvData.length > 0) {
            analyzeData();
        }
    });
});

function detectPipValue(pair) {
    const jpyPairs = ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY', 'NZDJPY', 'CADJPY', 'CHFJPY'];
    return jpyPairs.includes(pair.toUpperCase()) ? 0.01 : 0.0001;
}

function parseCSV(csvText) {
    try {
        const lines = csvText.trim().split('\n');
        
        // Auto-detect delimiter
        const firstLine = lines[0];
        const delimiter = firstLine.includes('\t') ? '\t' : ',';
        
        const headers = firstLine.toLowerCase().split(delimiter).map(h => h.trim());
        
        const dateIdx = headers.findIndex(h => h.includes('date') || h.includes('time'));
        const openIdx = headers.findIndex(h => h.includes('open'));
        const highIdx = headers.findIndex(h => h.includes('high'));
        const lowIdx = headers.findIndex(h => h.includes('low'));
        const closeIdx = headers.findIndex(h => h.includes('close'));
        const volumeIdx = headers.findIndex(h => h.includes('volume'));

        if ([dateIdx, openIdx, highIdx, lowIdx, closeIdx].some(i => i === -1)) {
            throw new Error('Required OHLC columns not found');
        }

        csvData = [];
        let skippedRows = 0;

        for (let i = 1; i < lines.length; i++) {
            const vals = lines[i].split(delimiter).map(v => v.trim());
            if (vals.length < 5) {
                skippedRows++;
                continue;
            }

            const dateObj = new Date(vals[dateIdx]);
            if (isNaN(dateObj.getTime())) {
                skippedRows++;
                continue;
            }

            const open = parseFloat(vals[openIdx]);
            const high = parseFloat(vals[highIdx]);
            const low = parseFloat(vals[lowIdx]);
            const close = parseFloat(vals[closeIdx]);
            const volume = volumeIdx !== -1 ? parseFloat(vals[volumeIdx]) : undefined;

            if ([open, high, low, close].some(isNaN) || high < low || open <= 0) {
                skippedRows++;
                continue;
            }

            // Calculate percentage change
            const changePercent = ((close - open) / open) * 100;

            csvData.push({
                date: vals[dateIdx],
                dateObj,
                open,
                high,
                low,
                close,
                changePercent,
                dailyAvg: (open + high + low + close) / 4,
                volume
            });
        }

        csvData.sort((a, b) => a.dateObj - b.dateObj);
        
        document.getElementById('analyzeBtn').disabled = false;
        document.getElementById('status').innerHTML = `<span class="success">✅ Loaded ${csvData.length} candles${skippedRows > 0 ? `, skipped ${skippedRows} invalid rows` : ''} - Starting automatic analysis...</span>`;
        
        // Auto-detect pair
        if (csvData.length > 0) {
            const avgPrice = csvData.reduce((sum, c) => sum + c.close, 0) / csvData.length;
            if (avgPrice > 100) {
                settings.forexPair = 'USDJPY';
                settings.pipValue = 0.01;
                document.getElementById('forexPair').value = 'USDJPY';
            }
        }
        
        // Automatically start analysis
        setTimeout(() => analyzeData(), 500);
        
    } catch (error) {
        document.getElementById('status').innerHTML = `<span class="error">❌ Error: ${error.message}</span>`;
    }
}

function percentile(arr, p) {
    const sorted = [...arr].sort((a, b) => a - b);
    const index = p * (sorted.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    const weight = index % 1;
    
    if (upper >= sorted.length) return sorted[sorted.length - 1];
    return sorted[lower] * (1 - weight) + sorted[upper] * weight;
}

// Calculate dynamic cluster size based on volatility
function calculateDynamicClusterSize(data) {
    const recentData = data.slice(-settings.volatilityLookback);
    if (recentData.length === 0) return settings.basePips * settings.pipValue;

    let totalRange = 0;
    for (let i = 1; i < recentData.length; i++) {
        const current = recentData[i];
        const previous = recentData[i - 1];
        
        const range1 = current.high - current.low;
        const range2 = Math.abs(current.high - previous.close);
        const range3 = Math.abs(current.low - previous.close);
        
        totalRange += Math.max(range1, range2, range3);
    }

    const avgTrueRange = totalRange / (recentData.length - 1);
    const dynamicPips = Math.max(
        settings.basePips * 0.5,
        Math.min(settings.basePips * 3, avgTrueRange / settings.pipValue)
    );

    return dynamicPips * settings.pipValue;
}

// Apply exponential decay weighting
function calculateExponentialWeight(index, totalLength) {
    const position = (totalLength - 1 - index) / (totalLength - 1);
    return Math.exp(-settings.exponentialDecay * position);
}

// Detect candlestick patterns
function detectCandlestickPatterns(candles, index) {
    const patterns = [];
    const current = candles[index];
    const previous = index > 0 ? candles[index - 1] : null;

    if (!current || !previous) return patterns;

    const body = Math.abs(current.close - current.open);
    const upperShadow = current.high - Math.max(current.open, current.close);
    const lowerShadow = Math.min(current.open, current.close) - current.low;
    const totalRange = current.high - current.low;

    // Pin Bar detection
    const shadowRatio = Math.max(upperShadow, lowerShadow) / totalRange;
    if (shadowRatio > 0.6 && body / totalRange < 0.3) {
        patterns.push({
            type: 'pinBar',
            strength: shadowRatio,
            bullish: lowerShadow > upperShadow
        });
    }

    // Engulfing pattern
    const prevBody = Math.abs(previous.close - previous.open);
    if (body > prevBody * 1.5) {
        const bullishEngulfing = current.close > current.open && 
                              previous.close < previous.open && 
                              current.close > previous.open &&
                              current.open < previous.close;
                              
        const bearishEngulfing = current.close < current.open && 
                              previous.close > previous.open && 
                              current.close < previous.open &&
                              current.open > previous.close;

        if (bullishEngulfing || bearishEngulfing) {
            patterns.push({
                type: 'engulfing',
                strength: body / prevBody,
                bullish: bullishEngulfing
            });
        }
    }

    // Inside Bar
    if (current.high <= previous.high && current.low >= previous.low) {
        patterns.push({
            type: 'insideBar',
            strength: 1 - (totalRange / (previous.high - previous.low)),
            bullish: current.close > current.open
        });
    }

    // Doji
    if (body / totalRange < 0.1 && totalRange > 0) {
        patterns.push({
            type: 'doji',
            strength: 1 - (body / totalRange),
            bullish: current.close > current.open
        });
    }

    return patterns;
}

function analyzeData() {
    if (csvData.length === 0) return;

    document.getElementById('status').innerHTML = '<span class="loading">⏳ Running enhanced cluster analysis on full dataset...</span>';
    document.getElementById('analyzeBtn').disabled = true;

    setTimeout(() => {
        // Use all CSV data instead of filtering by sessions
        const analysisData = csvData;
        if (analysisData.length === 0) {
            document.getElementById('status').innerHTML = '<span class="error">❌ No data found</span>';
            document.getElementById('analyzeBtn').disabled = false;
            return;
        }

        const clusters = {};
        const dynamicClusterSize = calculateDynamicClusterSize(analysisData);
        const totalDataPoints = analysisData.length;

        // Enhanced clustering with pattern detection - no session filtering
        const days = new Set();
        
        analysisData.forEach((candle, index) => {
            const dayKey = candle.dateObj.toDateString();
            days.add(dayKey);
            
            const cluster = Math.round(candle.dailyAvg / dynamicClusterSize) * dynamicClusterSize;
            const clusterKey = cluster.toFixed(8);

            if (!clusters[clusterKey]) {
                clusters[clusterKey] = {
                    cluster,
                    count: 0,
                    up: 0,
                    down: 0,
                    recentHits: 0,
                    changePercents: [],
                    highs: [],
                    lows: [],
                    closes: [],
                    history: [],
                    dayCount: 0,
                    candlestickPatterns: [],
                    dynamicClusterSize,
                    weightedSum: 0,
                    totalWeight: 0,
                    persistence: 0
                };
            }

            const clusterData = clusters[clusterKey];
            const weight = calculateExponentialWeight(index, totalDataPoints);
            
            clusterData.count++;
            clusterData.history.push(candle);
            clusterData.changePercents.push(candle.changePercent);
            clusterData.highs.push(candle.high);
            clusterData.lows.push(candle.low);
            clusterData.closes.push(candle.close);

            if (candle.close > candle.open) {
                clusterData.up++;
                clusterData.weightedSum += weight;
            } else {
                clusterData.down++;
                clusterData.weightedSum -= weight;
            }
            clusterData.totalWeight += weight;

            // Count recent hits (exponentially weighted)
            if (weight > 0.5) clusterData.recentHits++;

            // Detect candlestick patterns
            const patterns = detectCandlestickPatterns(analysisData, index);
            clusterData.candlestickPatterns.push(...patterns);

            // Track day diversity instead of session
            const candleDays = new Set(clusterData.history.map(c => c.dateObj.toDateString()));
            clusterData.dayCount = candleDays.size;
        });

        // Calculate enhanced statistics for each cluster
        analysis = Object.values(clusters).map(cluster => {
            cluster.upPct = (cluster.up / cluster.count) * 100;
            cluster.avgChangePercent = cluster.changePercents.reduce((a, b) => a + b, 0) / cluster.count;
            
            // Use percentiles for probable levels
            const sortedHighs = cluster.highs.sort((a, b) => a - b);
            const sortedLows = cluster.lows.sort((a, b) => a - b);
            const sortedCloses = cluster.closes.sort((a, b) => a - b);
            
            cluster.probableHigh = percentile(sortedHighs, 0.75);
            cluster.probableLow = percentile(sortedLows, 0.25);
            cluster.median = percentile(sortedCloses, 0.5);

            // Calculate volatility
            const mean = cluster.avgChangePercent;
            const variance = cluster.changePercents.reduce((sum, change) => sum + Math.pow(change - mean, 2), 0) / cluster.count;
            cluster.volatility = Math.sqrt(variance);

            // Calculate persistence (consecutive hits)
            let maxConsecutive = 0;
            let currentConsecutive = 0;
            for (let i = 1; i < cluster.history.length; i++) {
                if (cluster.history[i].dateObj.getTime() - cluster.history[i-1].dateObj.getTime() < 2 * 60 * 60 * 1000) {
                    currentConsecutive++;
                } else {
                    maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                    currentConsecutive = 0;
                }
            }
            cluster.persistence = maxConsecutive / cluster.count;

            // Enhanced confidence calculation
            const frequencyFactor = Math.min(cluster.count / totalDataPoints * 100, 40);
            const weightedBias = cluster.weightedSum / cluster.totalWeight;
            const consistencyFactor = Math.abs(weightedBias) * 50;
            const recentFactor = (cluster.recentHits / Math.max(cluster.count, 1)) * 30;
            const persistenceFactor = cluster.persistence * 20;
            const volatilityPenalty = Math.min(cluster.volatility * 2, 20);
            const dayBonus = Math.min(cluster.dayCount * 3, 15);
            const patternBonus = cluster.candlestickPatterns.reduce((sum, pattern) => sum + pattern.strength * 5, 0);

            cluster.confidence = Math.min(95, Math.max(10, 
                frequencyFactor + consistencyFactor + recentFactor + 
                persistenceFactor + dayBonus + patternBonus - volatilityPenalty
            ));

            // Risk/reward based on cluster extremes
            const risk = Math.abs(cluster.median - cluster.probableLow) / settings.pipValue;
            const reward = Math.abs(cluster.probableHigh - cluster.median) / settings.pipValue;
            cluster.riskReward = reward / Math.max(risk, 1);

            return cluster;
        }).sort((a, b) => b.confidence - a.confidence).slice(0, 15);

        displayResults();
        document.getElementById('analyzeBtn').disabled = false;
        document.getElementById('exportBtn').disabled = false;
        document.getElementById('status').innerHTML = `<span class="success">✅ Enhanced analysis complete on ${totalDataPoints} candles. Found ${analysis.length} clusters with ${(dynamicClusterSize/settings.pipValue).toFixed(1)} pip dynamic sizing.</span>`;
    }, 1500);
}

function formatPrice(price) {
    return price.toFixed(settings.pipValue === 0.01 ? 2 : 4);
}

function formatPips(price1, price2) {
    return Math.abs((price1 - price2) / settings.pipValue).toFixed(0);
}

function displayResults() {
    if (analysis.length === 0) return;

    const lastClose = csvData[csvData.length - 1].close;
    const topCluster = analysis[0];
    
    // Enhanced trading signal logic
    const direction = topCluster.median > lastClose ? 'LONG' : 'SHORT';
    const entry = lastClose;
    
    // Adjust stop-loss based on cluster volatility and patterns
    let stopLossMultiplier = 1.0;
    if (topCluster.volatility > 2.0) stopLossMultiplier *= 1.5;
    
    const strongPatterns = topCluster.candlestickPatterns.filter(p => p.strength > 0.7);
    if (strongPatterns.length > 0) stopLossMultiplier *= 0.8;
    
    let stopLoss, takeProfit;

    // Dataset extremes instead of session extremes
    const datasetHigh = Math.max(...csvData.map(c => c.high));
    const datasetLow = Math.min(...csvData.map(c => c.low));

    // Volatility buffer
    const volatilityBuffer = topCluster.volatility * topCluster.dynamicClusterSize / 100;

    // Minimum distance (in pips) for SL/TP to avoid unrealistic tight trades
    const minPipDistance = 8 * settings.pipValue;  // e.g. 8 pips
    const targetMultiple = 2.0;  // aim for at least 1:2 risk/reward

    if (direction === 'LONG') {
        // Stop-loss: below entry, but not tighter than min distance
        stopLoss = Math.max(datasetLow, entry - Math.max(topCluster.dynamicClusterSize, minPipDistance) - volatilityBuffer);

        // Take-profit: above entry, at least multiple of risk, capped at dataset high or median
        const risk = entry - stopLoss;
        takeProfit = Math.min(datasetHigh, entry + (risk * targetMultiple));
        takeProfit = Math.max(takeProfit, entry + minPipDistance);
    } else { // SHORT
        // Stop-loss: above entry, but not tighter than min distance
        stopLoss = Math.min(datasetHigh, entry + Math.max(topCluster.dynamicClusterSize, minPipDistance) + volatilityBuffer);

        // Take-profit: below entry, at least multiple of risk, capped at dataset low or median
        const risk = stopLoss - entry;
        takeProfit = Math.max(datasetLow, entry - (risk * targetMultiple));
        takeProfit = Math.min(takeProfit, entry - minPipDistance);
    }

    // Recalculate risk/reward
    const riskPips = parseFloat(formatPips(entry, stopLoss));
    const rewardPips = parseFloat(formatPips(takeProfit, entry));
    const riskReward = rewardPips / riskPips;

    // Check minimum risk:reward and confidence
    const meetsRiskReward = riskReward >= settings.minRiskReward;
    const meetsConfidence = topCluster.confidence >= settings.minConfidence;
    const shouldTrade = meetsRiskReward && meetsConfidence;

    // Position sizing
    const riskAmount = settings.accountBalance * settings.riskPercentage / 100;
    const positionSize = shouldTrade ? Math.floor(riskAmount / (riskPips * 1)) * 10000 : 0;

    // Trading forecast
    let forecastHtml;
    if (!shouldTrade) {
        const reason = !meetsRiskReward ? `Risk:Reward ${riskReward.toFixed(2)} below minimum ${settings.minRiskReward}` :
                      !meetsConfidence ? `Confidence ${topCluster.confidence.toFixed(0)}% below minimum ${settings.minConfidence}%` :
                      'Conditions not met';
        
        forecastHtml = `
            <div class="big-number neutral">NO TRADE</div>
            <div class="trade-suggestion no-trade">
                <strong>❌ NO TRADE SIGNAL:</strong><br>
                ${reason}<br><br>
                Current Risk:Reward: 1:${riskReward.toFixed(2)}<br>
                Current Confidence: ${topCluster.confidence.toFixed(0)}%
            </div>
        `;
    } else {
        forecastHtml = `
            <div class="big-number ${direction === 'LONG' ? 'bullish' : 'bearish'}">${direction}</div>
            <div class="data-row"><span>Entry:</span><span>${formatPrice(entry)}</span></div>
            <div class="data-row"><span>Take Profit:</span><span class="bullish">${formatPrice(takeProfit)}</span></div>
            <div class="data-row"><span>Stop Loss:</span><span class="bearish">${formatPrice(stopLoss)}</span></div>
            <div class="data-row"><span>Risk:Reward:</span><span class="badge badge-success">1:${riskReward.toFixed(2)}</span></div>
            <div class="data-row"><span>Confidence:</span><span class="badge badge-success">${topCluster.confidence.toFixed(0)}%</span></div>
            <div class="trade-suggestion">
                <strong>✅ COMPLETE SETUP:</strong><br>
                ${direction} ${settings.forexPair} @ ${formatPrice(entry)}<br>
                Position: ${(positionSize/1000).toFixed(0)}K units | Risk: $${riskAmount.toFixed(0)}
            </div>
        `;
    }

    document.getElementById('tradingForecast').innerHTML = forecastHtml;

    // Cluster summary
    document.getElementById('clusterSummary').innerHTML = `
        <div class="data-row"><span>Top Cluster:</span><span>${formatPrice(topCluster.cluster)}</span></div>
        <div class="data-row"><span>Total Hits:</span><span>${topCluster.count}</span></div>
        <div class="data-row"><span>Recent Hits:</span><span class="neutral">${topCluster.recentHits}</span></div>
        <div class="data-row"><span>Success Rate:</span><span class="badge ${topCluster.upPct > 50 ? 'badge-success' : 'badge-danger'}">${topCluster.upPct.toFixed(0)}%</span></div>
        <div class="data-row"><span>Volatility:</span><span>${topCluster.volatility.toFixed(2)}%</span></div>
        <div class="data-row"><span>Days:</span><span class="neutral">${topCluster.dayCount}</span></div>
        <div class="data-row"><span>Patterns:</span><span class="badge badge-warning">${topCluster.candlestickPatterns.length}</span></div>
        <div class="data-row"><span>Dynamic Size:</span><span>${(topCluster.dynamicClusterSize/settings.pipValue).toFixed(1)} pips</span></div>
    `;

    // Position sizing
    document.getElementById('positionSizing').innerHTML = `
        <div class="data-row"><span>Account Balance:</span><span>$${settings.accountBalance.toLocaleString()}</span></div>
        <div class="data-row"><span>Risk per Trade:</span><span>${settings.riskPercentage}%</span></div>
        <div class="data-row"><span>Dollar Risk:</span><span class="bearish">$${riskAmount.toFixed(0)}</span></div>
        <div class="data-row"><span>Risk Pips:</span><span class="bearish">${riskPips}</span></div>
        <div class="data-row"><span>Reward Pips:</span><span class="bullish">${rewardPips}</span></div>
        <div class="data-row"><span>Position Size:</span><span class="bullish">${(positionSize/1000).toFixed(0)}K units</span></div>
        <div class="data-row"><span>Min R:R Required:</span><span class="badge badge-warning">1:${settings.minRiskReward}</span></div>
        <div class="data-row"><span>Min Confidence:</span><span class="badge badge-warning">${settings.minConfidence}%</span></div>
    `;

    // Enhanced clusters table
    let tableHtml = `<table>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Cluster Level</th>
                <th>Hits</th>
                <th>Recent</th>
                <th>Success %</th>
                <th>High</th>
                <th>Low</th>
                <th>Median</th>
                <th>Volatility</th>
                <th>Confidence</th>
                <th>R:R</th>
                <th>Days</th>
                <th>Patterns</th>
                <th>Persistence</th>
            </tr>
        </thead>
        <tbody>`;

    analysis.forEach((cluster, i) => {
        const isTop = i === 0;
        const isBullish = cluster.upPct > 50;
        
        tableHtml += `<tr class="${isTop ? 'top-cluster' : ''}">
            <td>${isTop ? '<span class="badge badge-success">TOP</span>' : `#${i + 1}`}</td>
            <td style="font-family: monospace; font-weight: bold;">${formatPrice(cluster.cluster)}</td>
            <td>${cluster.count}</td>
            <td class="neutral">${cluster.recentHits}</td>
            <td><span class="badge ${isBullish ? 'badge-success' : 'badge-danger'}">${cluster.upPct.toFixed(0)}%</span></td>
            <td class="bullish" style="font-family: monospace;">${formatPrice(cluster.probableHigh)}</td>
            <td class="bearish" style="font-family: monospace;">${formatPrice(cluster.probableLow)}</td>
            <td style="font-family: monospace; font-weight: bold;">${formatPrice(cluster.median)}</td>
            <td>${cluster.volatility.toFixed(2)}%</td>
            <td><span class="badge ${cluster.confidence > 70 ? 'badge-success' : cluster.confidence > 50 ? 'badge-warning' : 'badge-danger'}">${cluster.confidence.toFixed(0)}%</span></td>
            <td><span class="badge ${cluster.riskReward >= 2 ? 'badge-success' : 'badge-warning'}">1:${cluster.riskReward.toFixed(2)}</span></td>
            <td class="neutral">${cluster.dayCount}</td>
            <td><span class="badge badge-warning">${cluster.candlestickPatterns.length}</span></td>
            <td>${(cluster.persistence * 100).toFixed(0)}%</td>
        </tr>`;
    });

    tableHtml += '</tbody></table>';
    tableHtml += `<div style="font-size: 11px; margin-top: 15px; padding: 15px; background: rgba(34, 197, 94, 0.1); border-radius: 8px; border-left: 3px solid #22c55e;">`;
    tableHtml += '<strong>🚀 Enhanced Analysis Notes:</strong><br>';
    tableHtml += '• <strong>Dynamic Clustering:</strong> Cluster size auto-adjusted based on recent volatility<br>';
    tableHtml += '• <strong>Exponential Weighting:</strong> Recent candles weighted more heavily<br>';
    tableHtml += '• <strong>Pattern Recognition:</strong> Pin bars, engulfing, inside bars, doji patterns detected<br>';
    tableHtml += '• <strong>Full Dataset Analysis:</strong> Complete CSV data processed without time restrictions<br>';
    tableHtml += '• <strong>Smart Risk Management:</strong> Volatility-adjusted stops with minimum R:R requirements<br>';
    tableHtml += '• <strong>Confidence Scoring:</strong> Frequency + Consistency + Recency + Persistence + Patterns - Volatility Penalty';
    tableHtml += '</div>';

    document.getElementById('clustersTable').innerHTML = tableHtml;

    // Show sections
    document.getElementById('forecastSection').style.display = 'grid';
    document.getElementById('clustersSection').style.display = 'block';
}

function downloadCSV() {
    if (analysis.length === 0) return;

    let csv = 'Rank,Pair,Cluster,TotalHits,RecentHits,SuccessRate,Volatility,ProbableHigh,ProbableLow,Median,Confidence,RiskReward,Days,Patterns,Persistence,DynamicSize\n';
    
    analysis.forEach((c, i) => {
        csv += `${i+1},${settings.forexPair},${c.cluster.toFixed(5)},${c.count},${c.recentHits},${c.upPct.toFixed(1)}%,${c.volatility.toFixed(2)}%,${c.probableHigh.toFixed(5)},${c.probableLow.toFixed(5)},${c.median.toFixed(5)},${c.confidence.toFixed(0)}%,${c.riskReward.toFixed(2)},${c.dayCount},${c.candlestickPatterns.length},${(c.persistence*100).toFixed(0)}%,${(c.dynamicClusterSize/settings.pipValue).toFixed(1)}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${settings.forexPair}_Enhanced_Cluster_Analysis.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
</script>
</body>
</html>
